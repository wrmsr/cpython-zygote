diff --git a/Include/pymem.h b/Include/pymem.h
index 10e8d93..a65c8c3 100644
--- a/Include/pymem.h
+++ b/Include/pymem.h
@@ -61,6 +61,7 @@ PyAPI_DATA(void *) _PyMem_ContiguousEnd;
 PyAPI_DATA(void *) _PyMem_PinnedBase;
 PyAPI_DATA(void *) _PyMem_PinnedEnd;
 
+PyAPI_DATA(int) _PyMem_USED_POOL_ARR_SIZE;
 PyAPI_DATA(int) _PyMem_ARENAS_USE_MMAP;
 
 #define Py_CONTIGUOUS(p)                             \
diff --git a/Lib/zygote/mallocstat.py b/Lib/zygote/mallocstat.py
index 63d24c2..365ebec 100644
--- a/Lib/zygote/mallocstat.py
+++ b/Lib/zygote/mallocstat.py
@@ -6,13 +6,6 @@ import ctypes
 import hashlib
 import sys
 
-usedpools_addr = ctypes.pythonapi._PyMem_usedpools_addr
-maxarenas_addr = ctypes.pythonapi._PyMem_maxarenas_addr
-arenas_addr = ctypes.pythonapi._PyMem_arenas_addr
-unused_arena_objects_addr = ctypes.pythonapi._PyMem_unused_arena_objects_addr
-usable_arenas_addr = ctypes.pythonapi._PyMem_usable_arenas_addr
-narenas_currently_allocated_addr = ctypes.pythonapi._PyMem_narenas_currently_allocated_addr
-
 
 class pool_header_ref(ctypes.Union):
     _fields_ = [
@@ -112,12 +105,42 @@ arena_object._fields_ = [
 ]
 
 
-pusedpools = ctypes.cast(usedpools_addr, pool_header_pp)
-pmaxarenas = ctypes.cast(maxarenas_addr, ctypes.POINTER(ctypes.c_uint))
-parenas = ctypes.cast(arenas_addr, arena_object_pp)
-punused_arena_objects = ctypes.cast(unused_arena_objects_addr, arena_object_pp)
-pusable_arenas = ctypes.cast(usable_arenas_addr, arena_object_pp)
-pnarenas_currently_allocated = ctypes.cast(narenas_currently_allocated_addr, arena_object_pp)
+class alloc_context(ctypes.Structure):
+    pass
+
+alloc_context_p = ctypes.POINTER(alloc_context)
+alloc_context_pp = ctypes.POINTER(alloc_context_p)
+
+# struct arena_object {
+alloc_context._fields_ = [
+
+    # /* Array of objects used to track chunks of memory (arenas). */
+    # struct arena_object* arenas;
+    ('arenas', arena_object_p),
+
+    # /* Number of slots currently allocated in the `arenas` vector. */
+    # uint maxarenas;
+    ('maxarenas', ctypes.c_uint),
+
+    # /* The head of the singly-linked, NULL-terminated list of available
+    # * arena_objects.
+    # */
+    # struct arena_object* unused_arena_objects;
+    ('unused_arena_objects', arena_object_p),
+
+    # /* The head of the doubly-linked, NULL-terminated at each end, list of
+    # * arena_objects associated with arenas that have pools available.
+    # */
+    # struct arena_object* usable_arenas;
+    ('usable_arenas', arena_object_p),
+
+    # /* Number of arenas allocated that haven't been free()'d. */
+    # size_t narenas_currently_allocated;
+    ('narenas_currently_allocated', ctypes.c_size_t),
+
+    # poolp usedpools[USED_POOL_ARR_SIZE];
+    ('usedpools', ctypes.c_void_p),
+]
 
 
 ALIGNMENT = 8
diff --git a/Lib/zygote/server.py b/Lib/zygote/server.py
index b210d64..c97631c 100644
--- a/Lib/zygote/server.py
+++ b/Lib/zygote/server.py
@@ -127,6 +127,7 @@ class ZygoteServer(ZygoteBase):
         self.daemonize = daemonize
         self.reap_interval = reap_interval
         self.child_pids = set()
+        self.last_reap = 0
 
     def setup_deathpact(self):
         self.setup_deathpact_as(True)
@@ -144,6 +145,12 @@ class ZygoteServer(ZygoteBase):
                 self.child_pids.remove(pid)
                 log.info('Reaped :: pid: %d, rc: %d' % (pid, rc))
 
+    def maybe_reap(self):
+        if time.time() - self.last_reap < self.reap_interval:
+            return
+        self.reap()
+        self.last_reap = time.time()
+            
     def run(self):
         if os.path.exists(self.path):
             raise ValueError(self.path, 'File already exists')
@@ -155,31 +162,24 @@ class ZygoteServer(ZygoteBase):
         self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
         self.sock.bind(self.path)
 
-        # FIXME listen w timeout, do this single threaded
-        class _nonlocal(object):
-            reaping = True
-        if not self.daemonize:
-            def reap():
-                while _nonlocal.reaping:
-                    self.reap()
-                    time.sleep(self.reap_interval)
-            reaper = threading.Thread(target=reap).start()
-        else:
-            reaper = None
-
-        try:
-            self.sock.listen(1)
-            log.info('Listening')
+        self.sock.listen(1)
+        log.info('Listening')
 
-            while True:
+        while True:
+            if not self.daemonize:
+                self.maybe_reap()
+                self.sock.settimeout(self.reap_interval)
+                try:
+                    conn, addr = self.sock.accept()
+                except socket.timeout:
+                    continue
+            else:
                 conn, addr = self.sock.accept()
-                log.info('Connection :: pid: %d, uid: %d, gid %d' % get_sock_cred(conn))
-                self.handle_conn(conn)
+            log.info('Connection :: pid: %d, uid: %d, gid %d' % get_sock_cred(conn))
+            self.handle_conn(conn)
 
-        finally:
-            if reaper is not None:
-                _nonlocal.reaping = False
-                reaper.join()
+        if not self.daemonize:
+            self.reap()
 
     def handle_conn(self, conn):
         if not self.exchange_magic(conn):
diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
index 400758d..3a85ea3 100644
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -560,6 +560,8 @@ struct alloc_context {
     poolp usedpools[USED_POOL_ARR_SIZE];
 };
 
+int _PyMem_USED_POOL_ARR_SIZE = USED_POOL_ARR_SIZE;
+
 void
 initialize_alloc_context(struct alloc_context *ac)
 {
diff --git a/ZYGOTE_NOTES b/ZYGOTE_NOTES
index 9a6a82c..8d63df3 100644
--- a/ZYGOTE_NOTES
+++ b/ZYGOTE_NOTES
@@ -9,7 +9,6 @@
 - page analyzer
 - pre-toucher / ideally modify page flags to let it happen naturally in fork()
 - /proc smaps + pagemap
-- https://www.kernel.org/doc/Documentation/vm/pagemap.txt
 - graceful fallback cfg'd in py, already available in ctypes.pythonapi
 - mallocstat can tell which arenas are pinned in py
 - port Py_PINNED to py
@@ -17,8 +16,6 @@
 - ... only things allocated are arenas, maintain freelist
  - sort and shrink
   - naw just double LL, choose least
-- pinstate to just a bool? can pin if contig?
-** count PyObject_Malloc fallbacks
  - fork friendly malloc? alloc all holes?
 - Memory mappings that have been marked with the madvise(2) MADV_DONTFORK flag are not inherited across a fork().
 - configurable bump allocation (for both pymalloc and jemalloc) - uh wow pin use remaining pinned space :||||
@@ -36,5 +33,5 @@ https://github.com/wrmsr/cpython-zygote/compare/master...wrmsr_zygote#files_buck
 
 http://neugierig.org/software/chromium/notes/2011/08/zygote.html
 
-* TODO allocation context struct
+* TODO allocation context struct - threadlocal
 - mp [billiard] worker pool, zmq pool
